---
RFC: RFC00XX
Author: Dongbo Wang
Status: Draft
Area: Microsoft.PowerShell.Core
Comments Due: 9/22/2021
Plan to implement: Yes
---

# Loading Modules into Isolated AssemblyLoadContext

Assembly isolation is a missing feature in PowerShell.
Today, a PowerShell process loads all assemblies in the default load context.
When an assembly is already loaded, it's not allowed to load the same assembly again with a different version.
This results in the PowerShell issue [#2083](https://github.com/PowerShell/PowerShell/issues/2083).
Basically, when two modules depend on different versions of the same assembly,
if the module that depends on the lower version is loaded first,
the other module cannot be loaded in the same session anymore.

The proposal is to allow Loading a module into a custom `AssemblyLoadContext`.
All the module required assemblies, all the assemblies loaded by `Add-Type` in the module script,
as well as assemblies produced by the PowerShell classes declared in the module,
will be loaded into the custom load context.

## Motivation

    As a PowerShell user, I'm able to use modules that depend on different versions of the same assembly in the same session.

## Specification

1. Create the type `PSModuleLoadContext` that derives from `AssemblyLoadContext` (ALC).
   This type will be the custom ALC used for the isolated modules.

1. Update `Import-Module` with two new parameters:

    ```powershell
    ## Import the module to an isolated AssemblyLoadContext.
    Import-Module [-Isolated]

    ## Import the module to the specified AssemblyLoadContext.
    Import-Module [[-AssemblyLoadContext] <PSModuleLoadContext>]
    ```
    - When `-Isolated` is specified,
      PowerShell creates a custom `AssemblyLoadContext` instance of the type `PSModuleLoadContext`,
      which will be associated with the module.

    - When `-AssemblyLoadContext` is specified,
      the given `PSModuleLoadContext` instance will be associated with the module.

    Unless otherwise instructed by the module author,
    all assembly loading triggered by loading the module or executing the module
    will have the assembly loaded into the associated assembly load context.

    > NOTE: A module author always can explicitly choose where to load an assembly, by:
    > - calling `LoadXXX` methods directly on an `AssemblyLoadContext` instance;
    > - changing the active assembly load context with `AssemblyLoadContext.EnterContextualReflection`;
    > - calling `Assembly.LoadFrom` to load an assembly to the default context;
    > - calling `Assembly.LoadFile` to load an assembly to a separate anonymous load context;

1. The `ModuleInfo` object will have a new public read-only property named `ReflectionContext`.
   It will hold a reference to the `PSModuleLoadContext` instance associated with the module.

    > NOTE: The `SessionState` or `SessionStateInternal` was considered when thinking about where to store the custom `PSModuleLoadContext` instance.
    > It was not chosen because a binary module does not have a `SessionStateInternal` created for it.

1. Nested modules should use the same ALC as the parent module.
   Nested modules belong to the parent module and commands are also exposed by the parent modules,
   so they should share the same ALC as the parent module.

1. Required modules are loaded into the default ALC as is today.
   The comment to the `RequiredModules` key in module manifest is:
   > Modules that must be imported into the global environment prior to importing this module.

   As indicated by the comment, required moduels are shared by all modules,
   so it makes most sense to always load a required module in the default ALC.

### Update Assembly Loading Logic

Today, PowerShell uses `Assembly.Load` and `Assembly.LoadFrom` for various assembly loading scenarios,
such as module loading and `Add-Type`.
- `Assembly.Load` infers the active ALC, which is the default ALC in our case
  because the `System.Management.Automation.dll` is always loaded in the default ALC.
- `Assembly.LoadFrom` is hardcoded to always load an assembly into the default ALC.
  It also sets up an event handler to `AppDomain.AssemblyResolve` to handle loading additional assemblies from the same folder path
  for future implicit assembly loading requests.

In addition, we have two more forms of assembly loading:
- For the dynamic assembly generated by `Add-Type` via `Compilation.Emit`
  we load it by `AssemblyLoadContext.Default.LoadFromStream`.
- For the dynamic assembly generated by PowerShell class using the `System.Reflection.Emit` APIs,
  it's loaded into the inferred active ALC, which is the default ALC today.

The assembly loading logic in PowerShell needs to be updated to make it aware of the correct ALC to use for the loading.
Furthermore, we need to set the contextual ALC before running a module command and restore it afterwards,
so that the explicit or implicit assembly loading triggered by the module command execution can be handled by the correct ALC.

- `AssemblyLoadContext.CurrentContextualReflectionContext` should be set before invoking a module command,
  and restored to the previous context after the invocation.
- `AssemblyLoadContext.CurrentContextualReflectionContext` should be set before running a command or script block in a module context (`& $module <cmd-or-script>`),
  and restored to the previous context after the invocation.

There is risk if we completely depend on the `AssemblyLoadContext.CurrentContextualReflectionContext` to get the active ALC to work with,
because that property can be changed by a user.
If `CurrentContextualReflectionContext` is changed to an arbitrary ALC,
we may run into weird type/assembly resolution issues.

So, I propose to add the new internal property `ExecutionContext.ActiveReflectionContext`,
which points to the currently active ALC that is supposed to be visible and usable in PowerShell.
If its value is `null`, then the currently active ALC is the default ALC.

Similarly, the setup and restore of this property should be done before and after command invocation:
- `ExecutionContext.ActiveReflectionContext` is set before invoking a module command,
  and restored to the previous context afterwards.
- `ExecutionContext.ActiveReflectionContext` is set before running a command or script block in a module context (`& $module <cmd-or-script>`),
  and restored to the previous context after the invocation.

### Update Type Resolution Logic

Now that we have custom ALC's for modules, the type resolving logic needs to be changed:

1. We should first look for the type within the `ExecutionContext.ActiveReflectionContext`,
and then revert back to the default ALC.
1. When reverting back to the default ALC,
we should ignore the assemblies that are loaded (and thus already searched) from the active ALC.

Since different versions of the same assemblies can be loaded into a custom ALC in PowerShell,
we may have type identity issues within a session -- type `C` and `C'` are the same type in terms of the fully-qualified type name,
but they are from two different assembly instances that are loaded into two load contexts.

In order to avoid type identity issue in type resolution and have it work consistently,
we need to do the following extra updates:

1. Today, we have a `TypeCache` data structure that maps a `Tuple<ITypeName, TypeResolutionState>` to a `Type`.
We will need to have separate `TypeCache` defined in the `PSModuleLoadContext` class,
so every custom ALC instance has its own type cache.
The existing `TypeCache` will become the type cache for the default ALC.

1. Today, we have `ExecutionContext.AssemblyCache` that holds all assemblies that are explicitly loaded by PowerShell.
Simiarly, we will need to have separate `AssemblyCache` defined in the `PSModuleLoadContext` class,
so every custom ALC instance has its own `AssemblyCache`.
The existing `AssemblyCache` will be for the default ALC exclusively.

1. All the `ITypeName` implementation types supports type caching.
The cached type of a `ITypeName` instance should be able to invalid the caching when `ExecutionContext.ActiveReflectionContext` changes.

## Potential Problems

### Module Interoperability

Imagine the assemblies A and B are loaded into ALC-M (isolated module M).
Assembly A exposes a cmdlet `Demo-Cmdlet` that has a parameter accepting an object of type `B::C`.

Scenario 1:
Let's say the default ALC doesn't contains the assembly B.
Then PowerShell won't be able to resolve the type `[B::C]` from outside the module M (e.g. from global scope),
because `[B::C]` can only be resolved within the ALC-M.

Scenario 2:
Let's say a different version of B was loaded into the default ALC,
and the result assembly instance is `B'`.
So, from the global scope,
one can create an object of `B'::C'` and call `Demo-Cmdlet` with it.
That call will result in a type casting exception with the confusing error like "cannot cast B::C to B::C".

- The behavior in the 1st scenario would be by design due to the nature of the module being isolated.
  The workaround would be `& $moudleM { [B::C] }`,
  but we have to admit that it would be confusing to PowerShell users,
  especially in cases like this example,
  where the exposed command expects the user to pass in an object of the type loaded by the module itself.

- The behavior in the 2nd scenario is because `B'::C'` and `B::C` are two different types,
  even though they have the same fully-qualified names and maybe members.
  This is a typical problem that could be caused by the type identity issue.

   This problem could also happen when `Import-Module M -Isolated` involves dealing with required modules.
   Since required modules will be loaded into the default ALC,
   there could be similar interoperability issues when M calls commands from its required modules.

We can mitigate the interoperability issue by improving the type resolution to make it aware of the module context,
with a new syntax for type reference: `[ModuleName\TypeName]`.

When the `ModuleName` part is specified,
PowerShell can check if such a module exists and whether it has a custom load context.
If it's a module with a custom load context,
then the type resolution will search assemblies from the custom-ALC and then the default-ALC to find the `TypeName`.
Otherwise, the type resolution will search the default-ALC only.

So in the 1st scenario above,
one can use `[M\B::C]` instead of `& $moudleM { [B::C] }`;
and in the 2nd scenario above,
it's possible to make it work as expected if we construct the object using `[M\B::C]` from the default-ALC.

> NOTE: The type identity issue is inevitable as soon as different versions of the same assembly can be loaded in the same PowerShell session.
> Improving the type resolution would definitely be helpful,
> but it would require the existing scripts to be updated before they can work with the modules loaded in separate load contexts.

### Caching Problem

PowerShell has a lot caches related to `System.Type`.
Some have `Type` as the value, such as the `TypeCache` in `TypeResolver` and the cached type for `ITypeName`.
Some have `Type` as the key, such as the member tables in `DotNetAdapter` and the binder caches in DLR.

For the former category, as was already mentioned above,
the cache data structure needs to be updated so as to make sure the cache is associated with a load context.

  - For example, when type resolution happens for `[C]` that is running from an isolated module M,
    then `TypeResolver` should use the cache associated with ALC-M.

  - Another example, if a `ITypeName` has already resolved the type via reflection in default-ALC,
    and the `ScriptBlock` containing that `ITypeName` is now being executed in the context of an isolated module M,
    then the cached type referred by `ITypeName` should be invalided and another resolution should be triggered.
    Similarly, if the `ScriptBlock` has already been compiled into LINQ expression tree and have the delegate generated,
    then the cached delegate needs to be voided and another compilation needs to be enforced to make sure type resolution is correct.

For the latter category, theoretically they will continue to work without change,
because types loaded into different load contexts are different.

### Reclaim Module AssemblyLoadContext

Starting from 3.0, .NET Core supports unloading an `AssemblyLoadContext` and all assemblies in it.
Ideally, we would like to reclaim the load context associated with an isolated module when the module is removed.

The cache updates called out in the [Update Type Resolution Logic](#update-type-resolution-logic) section
were designed with the purpose of allowing the custom ALC to be reclaimed.
By having each custom ALC to hold the cache data structure within itself,
we won't need to hold a custom ALC or any types loaded in a custom ALC as the key or value for any caches in our engine code,
and thus there is no need to invalidate any engine cache.

However, we won't be able to guarantee that a custom ALC could be unloaded at all.
This is because Dynamic Language Runtime (DLR) holds types in its cache, indefinitely.

The DLR types live in the default-ALC,
and it will generate a `DynamicMetaObject` object for a late-binding operation,
which is something like a key-value pair `<restrictions, expression>` that will be held in the DLR caches.
This is a perf improvement feature for dynamic languages like PowerShell because it allows you to skip an expensive late-binding operation when the `restrictions` matches.
That key-value pair will be held indefinitely,
so once types from a custom load context is involved in a late binding operation,
such as property access, method invocation and etc,
it will be rooted in the GC Heap by the DLR cache, and the custom load context cannot be unloaded afterwards.

## Summary

For the initial implementation, here are the goals and non-goals:

- Goals: work items called out in the [Specification](#specification) section,
  including updates to the module cmdlets, assembly loading, and type resolution.
- Non-goals: the new type reference syntax.

To emphasize again:
The type identity issue is inevitable as soon as different versions of the same assembly can be loaded in the same PowerShell session.
This will mainly affect modules that expect users to directly create objects of the types loaded by the modules.
